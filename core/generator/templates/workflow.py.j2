"""
{{ spec.description }}

Generated workflow from YAML definition.
Author: {{ spec.author }}
Version: {{ spec.version }}
Generated: {{ now().isoformat() }}
"""

import asyncio
import logging
import time
from pathlib import Path
from typing import Dict, Any, Optional

from core.agent.base import Agent, RetryPolicy
from core.agent.context import Context
from core.agent.state import StateResult
from core.resources.requirements import ResourceRequirements

# Import available integrations
{%- for integration in spec.integrations %}
{%- if integration.name in plugins %}
from plugins.{{ integration.name }} import {{ integration.name | pascal_case }}Plugin
{%- endif %}
{%- endfor %}

# Configure logging
logging.basicConfig(
    level=logging.{{ spec.environment.variables.get('LOG_LEVEL', 'INFO') }},
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class {{ spec.class_name }}Workflow:
    """{{ spec.description }}"""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        
        # Initialize agent
        self.agent = Agent(
            name="{{ spec.name }}",
            max_concurrent={{ spec.config.max_concurrent }},
            state_timeout={{ spec.config.state_timeout }},
            retry_policy=RetryPolicy(
                max_retries={{ spec.config.retry_policy.max_retries }},
                initial_delay={{ spec.config.retry_policy.initial_delay }},
                exponential_base={{ spec.config.retry_policy.exponential_base }},
                jitter={{ spec.config.retry_policy.jitter | python_value }}
            )
        )
        
        # Initialize plugins
        self.plugins = {}
{% for integration in spec.integrations %}
{% if integration.name in plugins %}
        self.plugins['{{ integration.name }}'] = {{ integration.name | pascal_case }}Plugin()
{% endif %}
{% endfor %}
        
        # Setup workflow states
        self._setup_states()
    
    def _setup_states(self):
        """Setup all workflow states."""
{% for state in spec.states %}
        self._add_state_{{ state.name | snake_case }}()
{% endfor %}

{%- for state in spec.states %}
    
    def _add_state_{{ state.name | snake_case }}(self):
        """Add {{ state.name }} state to workflow."""
{%- if state.type.startswith('builtin.') %}
        # Built-in state
        state_func = self._{{ state.name | snake_case }}_handler
{%- else %}
        # Plugin state
{%- set integration_name = state.type.split('.')[0] %}
{%- set action_name = state.type.split('.')[1] %}
        state_func = self._create_plugin_state_handler(
            '{{ integration_name }}', 
            '{{ action_name }}',
            {{ state.config | python_value }}
        )
{%- endif %}
        
        self.agent.add_state(
            "{{ state.name }}",
            state_func,
{%- if state.dependencies %}
            dependencies={
{%- for dep in state.dependencies %}
                "{{ dep.name }}": "{{ dep.type }}",
{%- endfor %}
            },
{%- endif %}
{%- if state.resources %}
            resources=ResourceRequirements(
                cpu_units={{ state.resources.cpu_units }},
                memory_mb={{ state.resources.memory_mb }},
                network_weight={{ state.resources.network_weight }},
                priority={{ state.resources.priority }},
{%- if state.resources.timeout %}
                timeout={{ state.resources.timeout }},
{%- endif %}
            ),
{%- endif %}
{%- if state.retry_policy %}
            retry_policy=RetryPolicy(
{%- for key, value in state.retry_policy.items() %}
                {{ key }}={{ value | python_value }},
{%- endfor %}
            ),
{%- endif %}
            max_retries={{ state.retry_policy.max_retries if state.retry_policy else 3 }}
        )

{%- if state.type.startswith('builtin.') %}
    
    async def _{{ state.name | snake_case }}_handler(self, context: Context) -> StateResult:
        """Handler for {{ state.name }} state."""
        logger.info("Executing state: {{ state.name }}")
        
        try:
{%- if state.type == 'builtin.start' %}
            # Start state - workflow initialization
            context.set_constant("workflow_start_time", time.time())
            context.set_constant("workflow_name", "{{ spec.name }}")
            context.set_constant("workflow_version", "{{ spec.version }}")
            logger.info("Starting workflow: {{ spec.name }}")
            
{%- elif state.type == 'builtin.end' %}
            # End state - workflow completion
            start_time = context.get_constant("workflow_start_time", time.time())
            duration = time.time() - start_time
            logger.info(f"Workflow {{ spec.name }} completed in {duration:.2f} seconds")
            
{%- elif state.type == 'builtin.transform' %}
            # Transform state - custom data processing
{%- if state.function %}
            # Custom function
{{ state.function | indent(12) }}
            
            result = await process(context)
            logger.info(f"Transform completed: {result}")
            return result
{%- else %}
            # Default transform
            logger.info("Transform state executed (no custom function)")
{%- endif %}
            
{%- elif state.type == 'builtin.conditional' %}
            # Conditional state - branching logic
{%- if state.config.get('condition') %}
            # Evaluate condition
            condition = """{{ state.config.condition }}"""
            # Safely evaluate the condition
            fetched_emails = context.get_state("fetched_emails", [])
            condition_result = eval(condition, {"context": context, "len": len, "fetched_emails": fetched_emails})
            logger.info(f"Condition evaluated to: {condition_result}")
            
{%- for transition in state.transitions %}
{%- if transition.condition == 'on_true' %}
            if condition_result:
                return "{{ transition.target }}"
{%- elif transition.condition == 'on_false' %}
            else:
                return "{{ transition.target }}"
{%- endif %}
{%- endfor %}
{%- endif %}
            
{%- elif state.type == 'builtin.delay' %}
            # Delay state
            delay_seconds = {{ state.config.get('seconds', 1) }}
            logger.info(f"Delaying for {delay_seconds} seconds")
            await asyncio.sleep(delay_seconds)
            
{%- elif state.type == 'builtin.error_handler' %}
            # Error handler state
            error_info = context.get_state("last_error")
            if error_info:
                logger.error(f"Handling error: {error_info}")
{%- if state.config.get('notify') %}
                context.set_state("error_notification_sent", True)
{%- endif %}
            
{%- endif %}
            # Handle transitions
{%- for transition in state.transitions %}
{%- if transition.condition in ['on_success', 'on_complete'] %}
            return "{{ transition.target }}"
{%- endif %}
{%- endfor %}
            
{%- if state.transitions|length == 0 %}
            return None
{%- endif %}
            
        except Exception as e:
            logger.error(f"Error in state {{ state.name }}: {str(e)}")
            context.set_state("last_error", str(e))
            
            # Handle error transitions
{%- for transition in state.transitions %}
{%- if transition.condition == 'on_failure' %}
            return "{{ transition.target }}"
{%- endif %}
{%- endfor %}
            
            raise
{%- endif %}
{%- endfor %}
    
    def _create_plugin_state_handler(self, plugin_name: str, action_name: str, config: Dict[str, Any]):
        """Create a handler for plugin states."""
        async def plugin_handler(context: Context) -> StateResult:
            logger.info(f"Executing plugin state: {plugin_name}.{action_name}")
            
            try:
                # Get plugin
                plugin = self.plugins.get(plugin_name)
                if not plugin:
                    raise ValueError(f"Plugin '{plugin_name}' not available")
                
                # Resolve any template variables in config
                resolved_config = {}
                for key, value in config.items():
                    if isinstance(value, str) and '{' + '{' in value and '}' + '}' in value:
                        # Simple template resolution for common variables
                        template_str = value
                        
                        # Extract variable names from template
                        import re
                        vars_in_template = re.findall(r'\{\{\s*(\w+)(?:\|(\w+))?\s*\}\}', template_str)
                        
                        for var_name, filter_name in vars_in_template:
                            var_value = context.get_state(var_name, [])
                            
                            # Apply filter if specified
                            if filter_name == 'length':
                                replacement = str(len(var_value))
                            else:
                                replacement = str(var_value)
                            
                            # Replace the template variable
                            template_pattern = r'\{\{\s*' + re.escape(var_name)
                            if filter_name:
                                template_pattern += r'\s*\|\s*' + re.escape(filter_name)
                            template_pattern += r'\s*\}\}'
                            
                            template_str = re.sub(template_pattern, replacement, template_str)
                        
                        resolved_config[key] = template_str
                    else:
                        resolved_config[key] = value
                
                # Get state function from plugin
                if hasattr(plugin, 'get_state_function'):
                    # Plugin uses get_state_function method
                    state_func = plugin.get_state_function(action_name, resolved_config)
                    result = await state_func(context)
                else:
                    # Plugin uses state classes directly
                    state_cls = plugin.register_states().get(action_name)
                    if not state_cls:
                        raise ValueError(f"Action '{action_name}' not found in plugin '{plugin_name}'")
                    
                    state_instance = state_cls(resolved_config)
                    result = await state_instance.execute(context)
                
                logger.info(f"Plugin state {plugin_name}.{action_name} completed")
                return result
                
            except Exception as e:
                logger.error(f"Error in plugin state {plugin_name}.{action_name}: {str(e)}")
                context.set_state("last_error", str(e))
                raise
        
        return plugin_handler
    
    async def run(self, timeout: Optional[float] = None) -> None:
        """Run the complete workflow."""
        logger.info(f"Starting workflow execution: {{ spec.name }}")
        
        try:
            # Use configured timeout or default
            workflow_timeout = timeout or {{ spec.config.timeout }}
            
            await self.agent.run(timeout=workflow_timeout)
            logger.info("Workflow execution completed successfully")
            
        except Exception as e:
            logger.error(f"Workflow execution failed: {str(e)}")
            raise
    
    async def run_from_state(self, state_name: str) -> None:
        """Run workflow starting from a specific state."""
        logger.info(f"Starting workflow from state: {state_name}")
        
        try:
            await self.agent.run_state(state_name)
            logger.info(f"Workflow execution from {state_name} completed")
            
        except Exception as e:
            logger.error(f"Workflow execution from {state_name} failed: {str(e)}")
            raise
    
    def get_status(self) -> Dict[str, Any]:
        """Get current workflow status."""
        return {
            "name": "{{ spec.name }}",
            "version": "{{ spec.version }}",
            "agent_status": self.agent.status.value if hasattr(self.agent.status, 'value') else str(self.agent.status),
            "completed_states": list(self.agent.completed_states),
            "running_states": list(self.agent._running_states),
            "total_states": len(self.agent.states),
            "plugins_loaded": list(self.plugins.keys())
        }


# Convenience function for external use
async def run_workflow(config: Optional[Dict[str, Any]] = None) -> None:
    """Convenience function to run the workflow."""
    workflow = {{ spec.class_name }}Workflow(config)
    await workflow.run()


# Entry point for direct execution
async def main():
    """Main entry point."""
    import os
    import yaml
    from pathlib import Path
    
    # Load configuration
    config_file = Path(__file__).parent.parent / "config" / "config.yaml"
    config = {}
    
    if config_file.exists():
        with open(config_file, 'r') as f:
            config = yaml.safe_load(f)
    
    # Override with environment variables
    for var_name, var_value in {
{%- for key, value in spec.environment.variables.items() %}
        "{{ key }}": "{{ value }}",
{%- endfor %}
    }.items():
        env_value = os.getenv(var_name, var_value)
        if env_value != var_value:
            config.setdefault('environment', {})[var_name] = env_value
    
    # Run the workflow
    await run_workflow(config)


if __name__ == "__main__":
    asyncio.run(main())